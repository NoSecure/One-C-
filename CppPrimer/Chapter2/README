以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。
列表初始化：
  int a = 0;
  int a = {0};
  int a{0};
  int a(0);
  花括号初始化有一个重要特点：如果用列表初始化且初始值存在丢失信息的风险，则编译器报错。如double b = 3.1415926536； int a{b};  转换不执行。
声明（declaration）：使名字为程序所知，一个文件如果想使用别处定义的名字必须包含对那个名字的声明。
定义（definition）：负责创建与名字关联的实体。
变量能且只能被定义一次，但是可以被多次声明。变量名前加extern是声明而非定义，如：
  extern int i;    //声明i而非定义i
  int j；          //声明并定义j
&和*既能用作表达式里的运算符，也能作为声明的一部分出现，虽然是同一个符号，但是含义截然不同。
空指针不指向任何对象，生成空指针的方法(作用相等）：
  int *p1 = nullptr;
  int *p2 = NULL;
  int *p3 = 0;
任何非0指针对应的条件值都是ture。
引用本身不是一个对象，不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：
  int i = 9;
  int *p;
  int *&r = p;   //r是一个对指针p的引用
  r = &i;        //r引用了一个指针，因此给r赋值&i就是令p指向i
  *r = 0;        //解引用r得到i，也就是p指向的对象，将i的值改为0
面对一条比较复杂的指针或引用的声明语句时，从右向左阅读。
const对象仅在文件内有效，多个文件中出现同名的const变量时，等同于在不用文件中分别定义了独立的变量。当一个const变量初始值不是一个常量表达式，
  但又有必要在文件间共享，则对const变量无论声明还是定义都添加extern关键字。
const引用 P54。const引用引用的对象是常量时不允许修改，是非常量时，不能通过const对象修改，允许通过其他途径改变引用的对象的值。
  int i = 9;
  int &r1 = i;
  const int &r2 = i;
  r1 = 0;            //正确
  r2 = 0;            //错误：r2是一个常量的引用，不允许通过r2修改i的值
typedef P61。
  typedef char *pstring;    //pstring是char*的别名
  const pstring cstr = 0;   //cstr是指向char的常量指针，不能理解成const char *cstr = 0;
  const pstring *ps;        //ps是一个指针，它的对象是指向char的常量指针
auto类型说明符定义的变量必须有初始值，定义多个变量时所有变量的初始基本数据类型都必须一样。
decltype(f()) sum = x;   //sum的类型就是函数f的返回类型。

#Exercise 3.6
#include <iostream>
#include <string>
#include <cctype>

using namespace std;

int main()
{
	string str;
	getline(cin, str);
	for(auto &c : str)
		c='X';
	cout << str;
	return 0;
}

#Exercise 3.17
#include <iostream>
#include <string>
#include <cctype>
#include <vector>

using namespace std;

int main()
{
	string str;
	vector<string> word;
	while(cin >> str)
	{
		word.push_back(str);
	}
	for(auto s : word)
	{
		for(auto &c : s)
		{
			c = toupper(c);
		}
		cout << s <<endl;
	}
	return 0;
}

